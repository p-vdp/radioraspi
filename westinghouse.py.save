import asyncio
import os
from subprocess import run

import gpiozero
from mpd import CommandError, MPDClient  # noqa


HOST = "localhost"
POLLING_RATE = 0.05
PORT = 6600

# GPIO pins
NC = 16  # LED normally closed
NO = 12  # LED normally open
PP = 4  # play/pause button
SB = 17  # shuffle button
TN = 5  # track next on rotary encoder
TP = 6  # track previous on rotary encoder
VD = 23  # volume down on rotary encoder
VU = 24  # volume up on rotary encoder


# noinspection PyUnresolvedReferences
def mpd_get_status(host=HOST, port=PORT) -> dict:
        client = MPDClient()
        client.connect(host, port)
        status = client.status()
        client.disconnect()
        del client
        return status


def mpd_is_alive(host=HOST, port=PORT):
    try:
        client = MPDClient()
        client.connect(host, port)
        print("MPD is alive!")
        client.disconnect()
        del client
        return True
    except ConnectionRefusedError:
        return False


def mpd_shuffle(host=HOST, port=PORT):
    client = MPDClient()
    client.connect(host, port)
    client.shuffle()  # noqa
    print('MDP playlist shuffled!')
    client.disconnect()
    del client
    return True


def mpd_toggle_pause(host=HOST, port=PORT):
    client = MPDClient()
    client.connect(host, port)
    client.pause()  # noqa
    print('MPD toggled play/pause')
    client.disconnect()
    del client
    return True


def mpd_previous_track(host=HOST, port=PORT):
    client = MPDClient()
    client.connect(host, port)

    try:
        client.previous()  # noqa
        print('Previous track')
        cmd = True
    except CommandError:
        cmd = False

    client.disconnect()
    del client
    return cmd


def mpd_next_track(host=HOST, port=PORT):
    client = MPDClient()
    client.connect(host, port)

    try:
        client.next()  # noqa
        print('Next track')
        cmd = True
    except CommandError:
        cmd = False

    client.disconnect()
    del client
    return cmd


def mpd_startup(host=HOST, port=PORT):
    # client = MPDClient()
    # try:
    #     client.shuffle()
    #     client.play()
    # finally:
    #     client.disconnect()
    #     del client
    pass


def mpd_volume_down(increment: int = 1):
    run(f"/var/www/util/vol.sh -dn {increment}", shell=True)


def mpd_volume_up(increment: int = 1):
    run(f"/var/www/util/vol.sh -up {increment}", shell=True)


def mpd_volume_get():
    out = run(f"/var/www/util/vol.sh", shell=True, capture_output=True)
    return int(out.stdout.decode().strip())


def mpd_volume_set(volume: int):
    run(f"/var/www/util/vol.sh {volume}", shell=True)


async def gpio_play_pause_button(play_pause_gpio: int = PP):
    button = gpiozero.Button(play_pause_gpio)
    initial_value = button.value
    while True:
        if button.value != initial_value:
            await asyncio.sleep(0.2)
            mpd_toggle_pause()
            await asyncio.sleep(1)

        await asyncio.sleep(POLLING_RATE)


async def gpio_play_indicator():
    last_state = None
    while True:
        play_state = mpd_get_status()["state"]
        if last_state != play_state:
            if play_state == "play":
                print("Playing, turning on bulb")
                led_no.on()
            elif play_state != "play":
                print("Not playing, turning off bulb")
                led_no.off()
            last_state = play_state
            await asyncio.sleep(1)

        await asyncio.sleep(POLLING_RATE)


async def gpio_shuffle_button(track_shuffle_button: int = SB):
    button = gpiozero.Button(track_shuffle_button)
    initial_value = button.value
    while True:
        current_value = button.value
        cycles_held = 0
        if current_value != initial_value:
            print('Shuffle button press, waiting....')
            action = 'shuffle'
            while current_value != initial_value:
                if cycles_held == 100:
                    led_nc.on()
                    led_no.off()
                    await asyncio.sleep(0.3)
                    led_nc.off()
                    action = 'restart'
                if cycles_held == 200:
                    action = 'shutdown'
                    led_nc.on()
                    os.system('sudo shutdown now')

                cycles_held += 1
                await asyncio.sleep(POLLING_RATE)
                current_value = button.value

            print('cycles held', cycles_held, action)

            match action:
                case 'shuffle':
                    mpd_shuffle()
                    await asyncio.sleep(0.2)
                    led_no.toggle()
                    await asyncio.sleep(0.1)
                    led_no.toggle()
                case 'restart':
                    os.system('sudo reboot')

            await asyncio.sleep(1)
        await asyncio.sleep(POLLING_RATE)


async def gpio_track_knob(track_previous_gpio: int = TP, track_next_gpio: int = TN):
    rotor = gpiozero.RotaryEncoder(
        track_previous_gpio, track_next_gpio, bounce_time=0.01
    )

    last_value = rotor.value
    while True:
        current_value = rotor.value

        if current_value < last_value:
            mpd_previous_track()

            led_no.off()
            await asyncio.sleep(0.1)
            led_no.on()
            await asyncio.sleep(1)

        if current_value > last_value:
            mpd_next_track()

            led_no.off()
            await asyncio.sleep(0.1)
            led_no.on()
            await asyncio.sleep(1)

        last_value = rotor.value
        await asyncio.sleep(POLLING_RATE)


async def gpio_volume_knob(
    volume_down_gpio: int = VD,
    volume_up_gpio: int = VU,
    min_vol: int = 0,
    max_vol: int = 50,
):
    rotor = gpiozero.RotaryEncoder(
        volume_down_gpio,
        volume_up_gpio,
        bounce_time=0.01,
        max_steps=max_vol,
        threshold_steps=(min_vol, max_vol),
        wrap=False,
    )

    rotor.steps = mpd_volume_get()

    last_value = rotor.steps
    while True:
        if rotor.steps <= min_vol:
            rotor.steps = min_vol

        if rotor.steps >= max_vol:
            rotor.steps = max_vol

        current_steps = rotor.steps

        if current_steps != last_value:
            mpd_volume_set(current_steps)
            last_value = current_steps
            print(f"volume set to {current_steps}")

        await asyncio.sleep(POLLING_RATE)


async def processes():
    async with asyncio.TaskGroup() as tg:
        tg.create_task(gpio_play_indicator())
        # tg.create_task(gpio_play_pause_button())  # use built-in Moode GPIO control instead, mpc,toggle
        tg.create_task(gpio_shuffle_button())
        tg.create_task(gpio_track_knob())
        # tg.create_task(gpio_volume_knob())  # use built-in Moode volume control instead


print("Starting westinghouse.py....")
led_nc = gpiozero.LED(NC)
led_no = gpiozero.LED(NO)

if __name__ == "__main__":
    print("Blinking once....")
    led_nc.blink(1, 1, 1, background=False)

    # print("Waiting for MPD....")
    # while mpd_is_alive() is False:
    #     print("MPD is down, blinking....")
    #     led_nc.blink(2, 2, 1, background=False)
    #
    # print("MPD is alive! Status:")
    # print(mpd_get_status())
    #
    # print("Running MPD startup script. Status:")
    # mpd_startup()

    print("Starting processes....")
    asyncio.run(processes())

    print("Exiting....")
